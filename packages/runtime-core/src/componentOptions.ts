import {
  ComponentInternalInstance,
  Data,
  SetupContext,
  ComponentInternalOptions,
  Component,
  ConcreteComponent,
  InternalRenderFunction,
  LifecycleHooks
} from './component'
import {
  isFunction,
  extend,
  isString,
  isObject,
  isArray,
  EMPTY_OBJ,
  NOOP,
  hasOwn,
  isPromise
} from '@vue/shared'
import { computed } from './apiComputed'
import {
  watch,
  WatchOptions,
  WatchCallback,
  createPathGetter
} from './apiWatch'
import { provide, inject } from './apiInject'
import {
  onBeforeMount,
  onMounted,
  onBeforeUpdate,
  onUpdated,
  onErrorCaptured,
  onRenderTracked,
  onBeforeUnmount,
  onUnmounted,
  onActivated,
  onDeactivated,
  onRenderTriggered,
  DebuggerHook,
  ErrorCapturedHook
} from './apiLifecycle'
import {
  reactive,
  ComputedGetter,
  WritableComputedOptions,
  toRaw,
  proxyRefs,
  toRef
} from '@vue/reactivity'
import {
  ComponentObjectPropsOptions,
  ExtractPropTypes,
  ExtractDefaultPropTypes
} from './componentProps'
import { EmitsOptions } from './componentEmits'
import { Directive } from './directives'
import {
  CreateComponentPublicInstance,
  ComponentPublicInstance
} from './componentPublicInstance'
import { warn } from './warning'
import { VNodeChild } from './vnode'
import { callWithAsyncErrorHandling } from './errorHandling'
import { UnionToIntersection } from './helpers/typeUtils'

/**
 * Interface for declaring custom options.
 *
 * @example
 * ```ts
 * declare module '@vue/runtime-core' {
 *   interface ComponentCustomOptions {
 *     beforeRouteUpdate?(
 *       to: Route,
 *       from: Route,
 *       next: () => void
 *     ): void
 *   }
 * }
 * ```
 */
export interface ComponentCustomOptions {}

export type RenderFunction = () => VNodeChild

type ExtractOptionProp<T> = T extends ComponentOptionsBase<
  infer P,
  any,
  any,
  any,
  any,
  any,
  any,
  any
>
  ? unknown extends P ? {} : P
  : {}

export interface ComponentOptionsBase<
  Props,
  RawBindings,
  D,
  C extends ComputedOptions,
  M extends MethodOptions,
  Mixin extends ComponentOptionsMixin,
  Extends extends ComponentOptionsMixin,
  E extends EmitsOptions,
  EE extends string = string,
  Defaults = {}
>
  extends LegacyOptions<Props, D, C, M, Mixin, Extends>,
    ComponentInternalOptions,
    ComponentCustomOptions {
  setup?: (
    this: void,
    props: Props &
      UnionToIntersection<ExtractOptionProp<Mixin>> &
      UnionToIntersection<ExtractOptionProp<Extends>>,
    ctx: SetupContext<E>
  ) => Promise<RawBindings> | RawBindings | RenderFunction | void
  name?: string
  template?: string | object // can be a direct DOM node
  // Note: we are intentionally using the signature-less `Function` type here
  // since any type with signature will cause the whole inference to fail when
  // the return expression contains reference to `this`.
  // Luckily `render()` doesn't need any arguments nor does it care about return
  // type.
  render?: Function
  components?: Record<string, Component>
  directives?: Record<string, Directive>
  inheritAttrs?: boolean
  emits?: (E | EE[]) & ThisType<void>
  // TODO infer public instance type based on exposed keys
  expose?: string[]
  serverPrefetch?(): Promise<any>

  // Internal ------------------------------------------------------------------

  /**
   * SSR only. This is produced by compiler-ssr and attached in compiler-sfc
   * not user facing, so the typing is lax and for test only.
   * @internal
   */
  ssrRender?: (
    ctx: any,
    push: (item: any) => void,
    parentInstance: ComponentInternalInstance,
    attrs: Data | undefined,
    // for compiler-optimized bindings
    $props: ComponentInternalInstance['props'],
    $setup: ComponentInternalInstance['setupState'],
    $data: ComponentInternalInstance['data'],
    $options: ComponentInternalInstance['ctx']
  ) => void

  /**
   * Only generated by compiler-sfc to mark a ssr render function inlined and
   * returned from setup()
   * @internal
   */
  __ssrInlineRender?: boolean

  /**
   * marker for AsyncComponentWrapper
   * @internal
   */
  __asyncLoader?: () => Promise<ConcreteComponent>
  /**
   * cache for merged $options
   * @internal
   */
  __merged?: ComponentOptions

  // Type differentiators ------------------------------------------------------

  // Note these are internal but need to be exposed in d.ts for type inference
  // to work!

  // type-only differentiator to separate OptionWithoutProps from a constructor
  // type returned by defineComponent() or FunctionalComponent
  call?: (this: unknown, ...args: unknown[]) => never
  // type-only differentiators for built-in Vnode types
  __isFragment?: never
  __isTeleport?: never
  __isSuspense?: never

  __defaults?: Defaults
}

export type ComponentOptionsWithoutProps<
  Props = {},
  RawBindings = {},
  D = {},
  C extends ComputedOptions = {},
  M extends MethodOptions = {},
  Mixin extends ComponentOptionsMixin = ComponentOptionsMixin,
  Extends extends ComponentOptionsMixin = ComponentOptionsMixin,
  E extends EmitsOptions = EmitsOptions,
  EE extends string = string
> = ComponentOptionsBase<
  Props,
  RawBindings,
  D,
  C,
  M,
  Mixin,
  Extends,
  E,
  EE,
  {}
> & {
  props?: undefined
} & ThisType<
    CreateComponentPublicInstance<{}, RawBindings, D, C, M, Mixin, Extends, E>
  >

export type ComponentOptionsWithArrayProps<
  PropNames extends string = string,
  RawBindings = {},
  D = {},
  C extends ComputedOptions = {},
  M extends MethodOptions = {},
  Mixin extends ComponentOptionsMixin = ComponentOptionsMixin,
  Extends extends ComponentOptionsMixin = ComponentOptionsMixin,
  E extends EmitsOptions = EmitsOptions,
  EE extends string = string,
  Props = Readonly<{ [key in PropNames]?: any }>
> = ComponentOptionsBase<
  Props,
  RawBindings,
  D,
  C,
  M,
  Mixin,
  Extends,
  E,
  EE,
  {}
> & {
  props: PropNames[]
} & ThisType<
    CreateComponentPublicInstance<
      Props,
      RawBindings,
      D,
      C,
      M,
      Mixin,
      Extends,
      E
    >
  >

export type ComponentOptionsWithObjectProps<
  PropsOptions = ComponentObjectPropsOptions,
  RawBindings = {},
  D = {},
  C extends ComputedOptions = {},
  M extends MethodOptions = {},
  Mixin extends ComponentOptionsMixin = ComponentOptionsMixin,
  Extends extends ComponentOptionsMixin = ComponentOptionsMixin,
  E extends EmitsOptions = EmitsOptions,
  EE extends string = string,
  Props = Readonly<ExtractPropTypes<PropsOptions>>,
  Defaults = ExtractDefaultPropTypes<PropsOptions>
> = ComponentOptionsBase<
  Props,
  RawBindings,
  D,
  C,
  M,
  Mixin,
  Extends,
  E,
  EE,
  Defaults
> & {
  props: PropsOptions & ThisType<void>
} & ThisType<
    CreateComponentPublicInstance<
      Props,
      RawBindings,
      D,
      C,
      M,
      Mixin,
      Extends,
      E,
      Props,
      Defaults,
      false
    >
  >

export type ComponentOptions<
  Props = {},
  RawBindings = any,
  D = any,
  C extends ComputedOptions = any,
  M extends MethodOptions = any,
  Mixin extends ComponentOptionsMixin = any,
  Extends extends ComponentOptionsMixin = any,
  E extends EmitsOptions = any
> = ComponentOptionsBase<Props, RawBindings, D, C, M, Mixin, Extends, E> &
  ThisType<
    CreateComponentPublicInstance<
      {},
      RawBindings,
      D,
      C,
      M,
      Mixin,
      Extends,
      E,
      Readonly<Props>
    >
  >

export type ComponentOptionsMixin = ComponentOptionsBase<
  any,
  any,
  any,
  any,
  any,
  any,
  any,
  any,
  any,
  any
>

export type ComputedOptions = Record<
  string,
  ComputedGetter<any> | WritableComputedOptions<any>
>

export interface MethodOptions {
  [key: string]: Function
}

export type ExtractComputedReturns<T extends any> = {
  [key in keyof T]: T[key] extends { get: (...args: any[]) => infer TReturn }
    ? TReturn
    : T[key] extends (...args: any[]) => infer TReturn ? TReturn : never
}

type WatchOptionItem =
  | string
  | WatchCallback
  | { handler: WatchCallback | string } & WatchOptions

type ComponentWatchOptionItem = WatchOptionItem | WatchOptionItem[]

type ComponentWatchOptions = Record<string, ComponentWatchOptionItem>

type ObjectInjectOptions = Record<
  string | symbol,
  string | symbol | { from?: string | symbol; default?: unknown }
>
type ComponentInjectOptions = string[] | ObjectInjectOptions

interface LegacyOptions<
  Props,
  D,
  C extends ComputedOptions,
  M extends MethodOptions,
  Mixin extends ComponentOptionsMixin,
  Extends extends ComponentOptionsMixin
> {
  // allow any custom options
  [key: string]: any

  // state
  // Limitation: we cannot expose RawBindings on the `this` context for data
  // since that leads to some sort of circular inference and breaks ThisType
  // for the entire component.
  data?: (
    this: CreateComponentPublicInstance<
      Props,
      {},
      {},
      {},
      MethodOptions,
      Mixin,
      Extends
    >,
    vm: CreateComponentPublicInstance<
      Props,
      {},
      {},
      {},
      MethodOptions,
      Mixin,
      Extends
    >
  ) => D
  computed?: C
  methods?: M
  watch?: ComponentWatchOptions
  provide?: Data | Function
  inject?: ComponentInjectOptions

  // composition
  mixins?: Mixin[]
  extends?: Extends

  // lifecycle
  beforeCreate?(): void
  created?(): void
  beforeMount?(): void
  mounted?(): void
  beforeUpdate?(): void
  updated?(): void
  activated?(): void
  deactivated?(): void
  /** @deprecated use `beforeUnmount` instead */
  beforeDestroy?(): void
  beforeUnmount?(): void
  /** @deprecated use `unmounted` instead */
  destroyed?(): void
  unmounted?(): void
  renderTracked?: DebuggerHook
  renderTriggered?: DebuggerHook
  errorCaptured?: ErrorCapturedHook

  // runtime compile only
  delimiters?: [string, string]

  /**
   * #3468
   *
   * type-only, used to assist Mixin's type inference,
   * typescript will try to simplify the inferred `Mixin` type,
   * with the `__differenciator`, typescript won't be able to combine different mixins,
   * because the `__differenciator` will be different
   */
  __differentiator?: keyof D | keyof C | keyof M
}

export type OptionTypesKeys = 'P' | 'B' | 'D' | 'C' | 'M' | 'Defaults'

export type OptionTypesType<
  P = {},
  B = {},
  D = {},
  C extends ComputedOptions = {},
  M extends MethodOptions = {},
  Defaults = {}
> = {
  P: P
  B: B
  D: D
  C: C
  M: M
  Defaults: Defaults
}

const enum OptionTypes {
  PROPS = 'Props',
  DATA = 'Data',
  COMPUTED = 'Computed',
  METHODS = 'Methods',
  INJECT = 'Inject'
}

function createDuplicateChecker() {
  const cache = Object.create(null)
  return (type: OptionTypes, key: string) => {
    if (cache[key]) {
      warn(`${type} property "${key}" is already defined in ${cache[key]}.`)
    } else {
      cache[key] = type
    }
  }
}

type DataFn = (vm: ComponentPublicInstance) => any

export let shouldCacheAccess = true

export function applyOptions(
  instance: ComponentInternalInstance,
  options: ComponentOptions
) {
  const publicThis = instance.proxy!
  const ctx = instance.ctx

  // we need to call the beforeCreate hook first,
  // because users may potentially modify the options in these hooks
  const { beforeCreate } = getOptions(publicThis)
  if (beforeCreate) {
    shouldCacheAccess = false
    callSyncHook(beforeCreate, instance, LifecycleHooks.BEFORE_CREATE)
    shouldCacheAccess = true
  }

  // get the options after the beforeCreate hooks is called
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // assets
    components,
    directives,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    // public API
    expose
  } = getOptions(publicThis)

  if (render && instance.render === NOOP) {
    instance.render = render as InternalRenderFunction
  }

  const checkDuplicateProperties = __DEV__ ? createDuplicateChecker() : null

  if (__DEV__) {
    const [propsOptions] = instance.propsOptions
    if (propsOptions) {
      for (const key in propsOptions) {
        checkDuplicateProperties!(OptionTypes.PROPS, key)
      }
    }
  }

  // options initialization order (to be consistent with Vue 2):
  // - props (already done outside of this function)
  // - inject
  // - methods
  // - data
  // - computed
  // - watch

  if (injectOptions) {
    if (isArray(injectOptions)) {
      for (let i = 0; i < injectOptions.length; i++) {
        const key = injectOptions[i]
        ctx[key] = inject(key)
        if (__DEV__) {
          checkDuplicateProperties!(OptionTypes.INJECT, key)
        }
      }
    } else {
      for (const key in injectOptions) {
        const opt = injectOptions[key]
        if (isObject(opt)) {
          ctx[key] = inject(
            opt.from || key,
            opt.default,
            true /* treat default function as factory */
          )
        } else {
          ctx[key] = inject(opt)
        }
        if (__DEV__) {
          checkDuplicateProperties!(OptionTypes.INJECT, key)
        }
      }
    }
  }

  if (methods) {
    for (const key in methods) {
      const methodHandler = (methods as MethodOptions)[key]
      if (isFunction(methodHandler)) {
        // In dev mode, we use the `createRenderContext` function to define methods to the proxy target,
        // and those are read-only but reconfigurable, so it needs to be redefined here
        if (__DEV__) {
          Object.defineProperty(ctx, key, {
            value: methodHandler.bind(publicThis),
            configurable: true,
            enumerable: true,
            writable: true
          })
        } else {
          ctx[key] = methodHandler.bind(publicThis)
        }
        if (__DEV__) {
          checkDuplicateProperties!(OptionTypes.METHODS, key)
        }
      } else if (__DEV__) {
        warn(
          `Method "${key}" has type "${typeof methodHandler}" in the component definition. ` +
            `Did you reference the function correctly?`
        )
      }
    }
  }

  if (dataOptions) {
    // @ts-ignore dataOptions is not fully type safe
    resolveData(instance, dataOptions, publicThis)
  }
  if (__DEV__) {
    const rawData = toRaw(instance.data)
    for (const key in rawData) {
      checkDuplicateProperties!(OptionTypes.DATA, key)
      // expose data on ctx during dev
      if (key[0] !== '$' && key[0] !== '_') {
        Object.defineProperty(ctx, key, {
          configurable: true,
          enumerable: true,
          get: () => rawData[key],
          set: NOOP
        })
      }
    }
  }

  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = (computedOptions as ComputedOptions)[key]
      const get = isFunction(opt)
        ? opt.bind(publicThis, publicThis)
        : isFunction(opt.get)
          ? opt.get.bind(publicThis, publicThis)
          : NOOP
      if (__DEV__ && get === NOOP) {
        warn(`Computed property "${key}" has no getter.`)
      }
      const set =
        !isFunction(opt) && isFunction(opt.set)
          ? opt.set.bind(publicThis)
          : __DEV__
            ? () => {
                warn(
                  `Write operation failed: computed property "${key}" is readonly.`
                )
              }
            : NOOP
      const c = computed({
        get,
        set
      })
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: v => (c.value = v)
      })
      if (__DEV__) {
        checkDuplicateProperties!(OptionTypes.COMPUTED, key)
      }
    }
  }

  for (const key in watchOptions) {
    createWatcher(watchOptions[key], ctx, publicThis, key)
  }

  if (provideOptions) {
    const provides = isFunction(provideOptions)
      ? provideOptions.call(publicThis)
      : provideOptions
    Reflect.ownKeys(provides).forEach(key => {
      provide(key, provides[key])
    })
  }

  // To reduce memory usage, only components with mixins or extends will have
  // resolved asset registry attached to instance.
  if (components && (components as any).asMixin) {
    instance.components = components as Record<string, ConcreteComponent> | null
  }
  if (directives && (directives as any).asMixin) {
    instance.directives = directives as Record<string, Directive> | null
  }

  // lifecycle options
  if (created) {
    callSyncHook(created, instance, LifecycleHooks.CREATED)
  }
  if (beforeMount) {
    registerHooks(beforeMount, onBeforeMount, instance.proxy!)
  }
  if (mounted) {
    registerHooks(mounted, onMounted, instance.proxy!)
  }
  if (beforeUpdate) {
    registerHooks(beforeUpdate, onBeforeUpdate, instance.proxy!)
  }
  if (updated) {
    registerHooks(updated, onUpdated, instance.proxy!)
  }
  if (activated) {
    registerHooks(activated, onActivated, instance.proxy!)
  }
  if (deactivated) {
    registerHooks(deactivated, onDeactivated, instance.proxy!)
  }
  if (errorCaptured) {
    registerHooks(errorCaptured, onErrorCaptured, instance.proxy!)
  }
  if (renderTracked) {
    registerHooks(renderTracked, onRenderTracked, instance.proxy!)
  }
  if (renderTriggered) {
    registerHooks(renderTriggered, onRenderTriggered, instance.proxy!)
  }
  if (__DEV__ && beforeDestroy) {
    warn(`\`beforeDestroy\` has been renamed to \`beforeUnmount\`.`)
  }
  if (beforeUnmount) {
    registerHooks(beforeUnmount, onBeforeUnmount, instance.proxy!)
  }
  if (__DEV__ && destroyed) {
    warn(`\`destroyed\` has been renamed to \`unmounted\`.`)
  }
  if (unmounted) {
    registerHooks(unmounted, onUnmounted, instance.proxy!)
  }

  if (isArray(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = proxyRefs({}))
      expose.forEach(key => {
        exposed[key] = toRef(publicThis, key as any)
      })
    } else if (!instance.exposed) {
      instance.exposed = EMPTY_OBJ
    }
  }
}

function resolveData(
  instance: ComponentInternalInstance,
  dataFn: DataFn,
  publicThis: ComponentPublicInstance
) {
  if (__DEV__ && !isFunction(dataFn)) {
    warn(
      `The data option must be a function. ` +
        `Plain object usage is no longer supported.`
    )
  }
  shouldCacheAccess = false
  const data = dataFn.call(publicThis, publicThis)
  shouldCacheAccess = true
  if (__DEV__ && isPromise(data)) {
    warn(
      `data() returned a Promise - note data() cannot be async; If you ` +
        `intend to perform data fetching before component renders, use ` +
        `async setup() + <Suspense>.`
    )
  }
  if (!isObject(data)) {
    __DEV__ && warn(`data() should return an object.`)
  } else if (instance.data === EMPTY_OBJ) {
    instance.data = reactive(data)
  } else {
    // existing data: this is a mixin or extends.
    extend(instance.data, data)
  }
}

function createWatcher(
  raw: ComponentWatchOptionItem,
  ctx: Data,
  publicThis: ComponentPublicInstance,
  key: string
) {
  const getter = key.includes('.')
    ? createPathGetter(publicThis, key)
    : () => (publicThis as any)[key]
  if (isString(raw)) {
    const handler = ctx[raw]
    if (isFunction(handler)) {
      watch(getter, handler as WatchCallback)
    } else if (__DEV__) {
      warn(`Invalid watch handler specified by key "${raw}"`, handler)
    }
  } else if (isFunction(raw)) {
    watch(getter, raw.bind(publicThis))
  } else if (isObject(raw)) {
    if (isArray(raw)) {
      raw.forEach(r => createWatcher(r, ctx, publicThis, key))
    } else {
      const handler = isFunction(raw.handler)
        ? raw.handler.bind(publicThis)
        : (ctx[raw.handler] as WatchCallback)
      if (isFunction(handler)) {
        watch(getter, handler, raw)
      } else if (__DEV__) {
        warn(`Invalid watch handler specified by key "${raw.handler}"`, handler)
      }
    }
  } else if (__DEV__) {
    warn(`Invalid watch option: "${key}"`, raw)
  }
}

export function resolveMergedOptions(
  instance: ComponentInternalInstance
): ComponentOptions {
  const raw = instance.type as ComponentOptions
  const { __merged, mixins, extends: extendsOptions } = raw
  if (__merged) return __merged
  const globalMixins = instance.appContext.mixins
  if (!globalMixins.length && !mixins && !extendsOptions) return raw
  const options = {}
  globalMixins.forEach(m => mergeOptions(options, m, instance))
  mergeOptions(options, raw, instance, false)
  return (raw.__merged = options)
}

function mergeOptions(
  to: any,
  from: any,
  instance: ComponentInternalInstance,
  asMixin = true
) {
  const strats = instance.appContext.config.optionMergeStrategies
  const { mixins, extends: extendsOptions } = from

  extendsOptions && mergeOptions(to, extendsOptions, instance)
  mixins &&
    mixins.forEach((m: ComponentOptionsMixin) => mergeOptions(to, m, instance))

  if (__DEV__ && asMixin && 'expose' in from) {
    delete from.expose
    warn(`The \`expose\` option is ignored when used in mixins.`)
  }

  for (const key in from) {
    if (strats && hasOwn(strats, key)) {
      to[key] = strats[key](to[key], from[key], instance.proxy, key, asMixin)
    } else if (key in defaultMergeStrategies) {
      to[key] = defaultMergeStrategies[key](
        to[key],
        from[key],
        instance.proxy!,
        key,
        asMixin
      )
    } else {
      to[key] = from[key]
    }
  }
}

const defaultMergeStrategies: Record<string, Function> = {
  data(
    toValue: DataFn | undefined,
    fromValue: DataFn | undefined,
    publicThis: ComponentPublicInstance
  ) {
    if (!fromValue) return toValue
    if (!toValue) return fromValue

    return function mergeDataFn() {
      return extend(
        {},
        toValue.call(publicThis, publicThis),
        fromValue.call(publicThis, publicThis)
      )
    }
  },
  watch(
    toValue: ComponentWatchOptions | undefined,
    fromValue: ComponentWatchOptions | undefined
  ) {
    if (!toValue) return fromValue
    if (!fromValue) return toValue

    const ret: ComponentWatchOptions = Object.create(null)
    extend(ret, toValue)
    for (const key in fromValue) {
      let existing = ret[key]
      const from = fromValue[key]
      if (existing && !isArray(existing)) {
        existing = [existing]
      }
      ret[key] = existing ? (existing as WatchOptionItem[]).concat(from) : from
    }

    return ret
  },
  inject(
    toValue: ComponentInjectOptions | undefined,
    fromValue: ComponentInjectOptions | undefined
  ): ObjectInjectOptions | undefined {
    toValue = normalizeInject(toValue)
    fromValue = normalizeInject(fromValue)
    if (!fromValue) return toValue
    if (!toValue) return fromValue
    return extend(Object.create(null), toValue, fromValue)
  },
  provide(
    toValue: Data | Function | undefined,
    fromValue: Data | Function | undefined,
    publicThis: ComponentPublicInstance
  ) {
    return function mergeProvideFn() {
      return extend(
        Object.create(null),
        isFunction(toValue) ? toValue.call(publicThis) : toValue,
        isFunction(fromValue) ? fromValue.call(publicThis) : fromValue
      )
    }
  },
  render(
    toValue: InternalRenderFunction | undefined,
    fromValue: InternalRenderFunction | undefined
  ) {
    return fromValue || toValue
  }
}
;([
  'beforeCreate',
  'created',
  'beforeMount',
  'mounted',
  'beforeUpdate',
  'updated',
  'activated',
  'deactivated',
  'beforeDestroy',
  'beforeUnmount',
  'destroyed',
  'unmounted',
  'renderTracked',
  'renderTriggered',
  'errorCaptured'
] as const).forEach(hookName => {
  defaultMergeStrategies[hookName] = function mergeHook(
    toValue?: Function | Function[],
    fromValue?: Function
  ) {
    if (!fromValue) return toValue
    toValue = toValue ? (isArray(toValue) ? toValue : [toValue]) : undefined

    return toValue ? toValue.concat(fromValue) : fromValue
  }
})
;(['components', 'directives'] as const).forEach(assetName => {
  defaultMergeStrategies[assetName] = function mergeAssets(
    toValue: Record<string, ConcreteComponent> | null,
    fromValue: Record<string, ConcreteComponent> | null,
    publicThis: ComponentPublicInstance,
    key: string,
    asMixin: boolean
  ) {
    if (!fromValue) return toValue
    const ret = toValue ? extend(Object.create(toValue), fromValue) : fromValue

    if (!toValue) {
      Reflect.setPrototypeOf(ret, { asMixin })
    }

    return ret
  }
})
;(['methods', 'computed'] as const).forEach(optionName => {
  defaultMergeStrategies[optionName] = function(
    toValue?: Record<string, Function>,
    fromValue?: Record<string, Function>
  ) {
    if (!fromValue) return toValue
    if (!toValue) return fromValue
    return extend(Object.create(null), toValue, fromValue)
  }
})

function normalizeInject(
  injectOption?: ComponentInjectOptions
): ObjectInjectOptions | undefined {
  if (!injectOption) return
  const normalized = Object.create(null)
  if (isArray(injectOption)) {
    for (let i = 0; i < injectOption.length; i++) {
      normalized[injectOption[i]] = { from: injectOption[i] }
    }
    return normalized
  }
  return injectOption
}

function callSyncHook(
  hooks: Function | Function[],
  instance: ComponentInternalInstance,
  type: LifecycleHooks
) {
  hooks = isArray(hooks) ? hooks : [hooks]
  hooks.forEach(hook => {
    callWithAsyncErrorHandling(hook.bind(instance.proxy!), instance, type)
  })
}

function registerHooks(
  hooks: Function | Function[],
  hooker: Function,
  publicThis: ComponentPublicInstance
) {
  hooks = isArray(hooks) ? hooks : [hooks]
  hooks.forEach(hook => hooker(hook.bind(publicThis)))
}

function getOptions(instance: ComponentPublicInstance) {
  return instance.$options
}
